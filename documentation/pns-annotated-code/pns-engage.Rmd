---
title: "Annotated Code and Summary Statistics"
geometry: margin=1in
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    number_sections: yes
  html_document:
    number_sections: yes
---

```{css, echo=FALSE}
.inside-code {
background-color: #abeeca;
}

.line-code {
background-color: #8bd7de;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.align = "center")
```

The script, `pns-engage.R`, takes raw data from the PNS study, performs a series of data processing tasks, and then produces a dataset to be used in analyses. The functions called in this script implement decisions made during the process of curating data. We provide details of the most important functions, annotated code, and summary statistics on the amount of data retained after specific data processing steps. Code from `pns-engage.R` are highlighted in marked in <span style="background-color: #8bd7de">`sky blue`</span> (code highlights are visible in html version of this document).

```{r, include = FALSE}
library(dplyr)
library(magrittr)
library(assertthat)

path.pns.input_data <- Sys.getenv("path.pns.input_data")
path.pns.output_data <- Sys.getenv("path.pns.output_data")
path.pns.code <- Sys.getenv("path.pns.code")
path.shared.code <- Sys.getenv("path.shared.code")
source(file.path(path.pns.code, "pns-data-manip-utils.R"))
source(file.path(path.shared.code, "shared-data-manip-utils.R"))
```

# Details of the `SetUpPostQuit()` function

The function `SetUpPostQuit(df.raw, df.time.frame){...}` implements data processing tasks performed for all analyses using PNS study data. Here, we annotate code `{...}` within this function, highlighted in <span style="background-color: #abeeca">`sea green`</span>. First, let us create the `df.time.frame` and `df.raw` variables, which are inputs to this function.

```{r}
pns.quit.dates <- read.csv(file.path(path.pns.input_data, "pns_quit_dates.csv"))
df.time.frame <- SetTimeFrame(df.quit.dates = pns.quit.dates, 
                              study.duration = 21, 
                              addtime = 0)

# Note: When using SetUpPostQuit() for other analyses, 
# df.raw could alternatively be one of the other PNS Post Quit data 
df.raw <- read.csv(file.path(path.pns.input_data, "Post_Quit_Random.csv"))
```

Time variables prefixed by `delivered.` and `assessment.` pertain to time when an EMA was delivered, and when a participant began completing an EMA, respectively.

```{r, class.source="inside-code"}
# Rename variables in raw data and create new time variables
df.out <- df.raw %>%
  rename(id = Part_ID, 
         record.id = Record_ID,
         record.status = Record_Status,
         assessment.type = Asse_Name, 
         delivered.hrts = Initiated, # Time when EMA was delivered
         assessment.hrts = AssessmentBegin  # Time when participant began completing EMA
         ) %>% 
  mutate(record.id = as.character(record.id),
         assessment.type = as.character(assessment.type), 
         delivered.hrts = as.character(delivered.hrts),
         assessment.hrts = as.character(assessment.hrts)) %>%
  mutate(delivered.unixts = as.POSIXct(strptime(delivered.hrts, 
                                                format = "%m/%d/%Y %I:%M:%S %p", 
                                                tz="EST5EDT")),
         assessment.unixts = as.POSIXct(strptime(assessment.hrts, 
                                                 format = "%m/%d/%Y %I:%M:%S %p", 
                                                 tz="EST5EDT"))) %>%
  mutate(delivered.unixts = as.numeric(delivered.unixts),
         assessment.unixts = as.numeric(assessment.unixts)) %>%
  mutate(delay = assessment.unixts - delivered.unixts)
```

```{r}
# How many EMAs are in df.out now?
nrow(df.out)

# Sanity check: Do all EMAs have a timestamp corresponding to time delivered?
# If this is the case, the output should be `TRUE`
nrow(df.out) == sum(!is.na(df.out$delivered.unixts))
```

Each row in `df.raw` contains a time stamp of when an EMA was delivered; rows in `df.raw` corresponding to EMAs delivered outside lower and upper time bounds specified in `df.time.frame` are excluded.

```{r, class.source="inside-code"}
# Decision rule: exclude EMAs delivered before start of clock or
# after end of clock
df.out <- df.out %>%
  left_join(x = ., y = df.time.frame, by = "id") %>%
  filter(delivered.unixts >= start.clock & delivered.unixts <= end.clock) %>%
  arrange(id, delivered.unixts)
```

```{r}
# How many EMAs are in df.out now?
nrow(df.out)
```

The `Responded` and `Completed` variables in the raw data pertain to timestamps of when participants began responding or completed EMAs, respectively. `Responded` has two levels, `True` and `Missing` while `Completed` has three levels, `True`, `False`, and `Missing`.

```{r, class.source="inside-code"}
df.out <- df.out %>% 
  mutate(Responded = as.character(Responded),
         Completed = as.character(Completed)) %>%
  mutate(Responded = if_else(Responded=="","Missing",Responded),
         Completed = if_else(Completed=="","Missing",Completed))

# Tabulate combination values from these two variables
table(df.out$Responded, df.out$Completed)
```

Let us investigate the record status of the groups with a missing value.
```{r}
df.out %>% 
  filter(Responded=="Missing" & Completed=="Missing") %>% 
  group_by(record.status) %>%
  summarise(n())

df.out %>% 
  filter(Responded=="Missing" & Completed=="False") %>% 
  group_by(record.status) %>%
  summarise(n())

df.out %>% 
  filter(Responded=="True" & Completed=="Missing") %>% 
  group_by(record.status) %>%
  summarise(n())
```

```{r, class.source="inside-code"}
# Decision rule: exclude EMAs that are "not valid"
df.out <- df.out %>% 
  filter((Responded=="True" & Completed=="True")|
           (Responded=="True" & Completed=="False")|
           (Responded=="True" & Completed=="Missing")|
           (Responded=="Missing" & Completed=="False")) %>%
  rename(responded=Responded,
         completed=Completed)
```

```{r}
# How many EMAs are in df.out now?
nrow(df.out)
```

Let us investigate the time between when an EMA is delivered to a participant (time variables prefixed by `delivered.`) and the time when a participant actually begins completing an EMA (time variables prefixed by `assessment.`).
```{r}
df.out %>%
  summarise(no.record = sum(is.na(assessment.unixts)),
            with.record = sum(!is.na(assessment.unixts)),
            prop.positive = sum((!is.na(delay)) & (delay>0))/with.record,
            prop.zero = sum((!is.na(delay)) & (delay==0))/with.record,
            prop.negative = sum((!is.na(delay)) & (delay<0))/with.record,
            MIN = min(delay, na.rm=TRUE)/(60*60),  # in hours
            MAX = max(delay, na.rm=TRUE)/(60*60)   # in hours
            )
```

```{r, class.source="inside-code"}
# Decision rule: exclude EMAs based on difference between
# assessment.unixts and delivered.unixts
df.out <- df.out  %>% filter(is.na(delay)|(delay >= 0))
```

```{r}
# How many EMAs are in df.out now?
nrow(df.out)
```

Now, let us get a sense of the volume of data remaining for each participant.

```{r}
df.out %>%
  group_by(id) %>%
  summarise(tot.prompts = n()) %>%
  summarise(MEAN = mean(tot.prompts),
            MIN = min(tot.prompts),
            MAX = max(tot.prompts))

df.out %>%
  filter(responded=="True") %>%
  group_by(id) %>%
  summarise(tot.prompts = n()) %>%
  summarise(MEAN = mean(tot.prompts),
            MIN = min(tot.prompts),
            MAX = max(tot.prompts))

df.out %>%
  filter(completed=="True") %>%
  group_by(id) %>%
  summarise(tot.prompts = n()) %>%
  summarise(MEAN = mean(tot.prompts),
            MIN = min(tot.prompts),
            MAX = max(tot.prompts))
```

Let us now create the variable`with.any.response`. This variable is an indicator for whether there is any recorded response in each row of `df.out`.

```{r, echo=FALSE}
these.cols <- c("record.id",             
                "record.status",         
                "id",                    
                "Day",                   
                "delivered.hrts",        
                "InitiatedDate",         
                "InitiatedTime",         
                "SnzCount",              
                "SnzTime1",              
                "SnzTime2",              
                "SnzTime3",              
                "SnzTime4",              
                "assessment.hrts",       
                "AssessmentCancelled",   
                "ParticipantComplied",   
                "AssessmentID",          
                "assessment.type",       
                "Asse_Type",             
                "Asse_Mode",             
                "AssessmentEnd",         
                "responded",             
                "completed",             
                "AssessmentCompleted",   
                "AssessmentNOTCompleted",
                "AssessmentTimedOut",    
                "StartDate",             
                "Quit_Date1",            
                "Quit_Date2",            
                "Quit_Date3",            
                "Quit_Date4",            
                "Quit_Date5",   
                "X",                     
                "delivered.unixts",      
                "assessment.unixts",     
                "delay",                 
                "quit.date",             
                "start.clock",           
                "end.clock") 
```

```{r}
# Calling CheckAnyResponse() constructs these variables
df.out <- CheckAnyResponse(df = df.out, drop.cols = these.cols)
```

```{r}
df.out %>% 
  mutate(check.condition = (with.any.response==1)) %>%
  filter(check.condition) %>%
  group_by(id) %>%
  summarise(tot.prompts = n()) %>%
  summarise(MEAN = mean(tot.prompts),
            MIN = min(tot.prompts),
            MAX = max(tot.prompts))
```


```{r}
df.out %>% 
  group_by(with.any.response, record.status, responded, completed) %>%
  summarise(num.ema=n()) %>%
  arrange(with.any.response, desc(record.status))

```

# How do we operationalize engagement in completion of EMAs?

Let us count the number of EMAs corresponding to a `TRUE` value for the variables `with.any.response`, or `responded`, or `completed`.


```{r}
df.out %>% 
  summarise(tot.ema = n(),
            tot.with.any.response = sum(with.any.response),
            tot.responded = sum(responded=="True"),
            tot.completed = sum(completed=="True"),
            prop.with.any.response = tot.with.any.response/tot.ema,
            prop.responded = tot.responded/tot.ema,
            prop.completed = tot.completed/tot.ema
            )
```

Let us determine the type of timestamps these variables have.

```{r}
df.out %>% 
  mutate(is.missing.ass = is.na(assessment.unixts),
         is.missing.del = is.na(delivered.unixts)) %>%
  group_by(with.any.response, 
           responded, 
           completed,
           is.missing.ass,
           is.missing.del,
           record.status) %>%
  summarise(num.ema = n()) %>%
  print(width=Inf)
```

The table shows that all EMAs in `df.out` have the timestamp `delivered.unixts`. However, the EMAs having `responded==Missing` and `is.missing.assessment.unixts==FALSE` are unexpected. Also, observe that when `with.any.response==1`, the associated EMA always has an `assessment.unixts` timestamp and an `delivered.unixts` timestamp. On the other hand, observe that when `with.any.response==0`, the associated EMA always has an `delivered.unixts` timestamp.

```{r}
df.post.quit.random <- df.out
```

The variable `engage.yes` is used to operationalize engagement with EMA completion; it is a binary variable equal to 1 if `with.any.response` is equal to 1 and equal to 0 otherwise.

```{r, class.source="line-code"}
# Implement decision rules for outcome variable engaged.yes
df.post.quit.random <- df.post.quit.random %>% 
  mutate(engaged.yes = with.any.response)
```

Let us count the number of EMAs corresponding to a `TRUE` value for the variables `engaged.yes`.

```{r}
df.post.quit.random %>% 
  summarise(tot.ema = n(),
            tot.engaged = sum(engaged.yes),
            prop.engaged = tot.engaged/tot.ema)
```

# Time associated with each EMA in data analyses

Let the variable `time.unixts.scaled` be the time elapsed since quit (in seconds). How is this variable calculated for EMAs when a participant engaged in completion and for EMAs when participants did not engage in completion? 


We see that there can be about a 5-minute to 20-minute time gap between `assessment.unixts` and `delivered.unixts` among 5% of EMAs with a `assessment.unixts` timestamp.

```{r}
quantile((df.post.quit.random$delay)/60, c(0, 0.50, 0.95, 1), na.rm = TRUE) # in minutes
```

How many EMAs have `delay` greater than 20 minutes?

```{r}
df.post.quit.random %>% filter(delay > 20*60) %>% summarise(num.ema=n())
```

When participant engages EMA completion (i.e., `engaged.yes==1`), then time when s/he began the assessment (the variable `assessment.unixts`) is associated with the EMA in the variable `time.unixts`. On the other hand when a participant does not engage in EMA completion, then the time when EMA was delivered (the variable `delivered.unixts`) is associated with the EMA in the variable `time.unixts`. Hence, time elapsed since quit is then the difference between `time.unixts` and Quit Time (the variable `start.clock`, which represents 4am on Quit Day). This is implemented using the code below.

```{r, class.source="line-code"}
# Implement decision rules for:
# (1) Timestamp when engaged.yes=1
# (2) Timestamp when engaged.yes=0
df.post.quit.random <- df.post.quit.random %>%
  mutate(time.unixts = if_else(engaged.yes == 1, assessment.unixts, delivered.unixts)) %>%
  mutate(time.unixts.scaled = time.unixts - start.clock) %>%
  mutate(delivered.unixts.scaled = delivered.unixts - start.clock) %>%
  mutate(assessment.unixts.scaled = assessment.unixts - start.clock)
```

# Number of participants in the dataset

Let us compare the number of participant IDs recorded in the post-quit random raw data, analytic dataset, and in a listing of quit dates recorded by study staff.

```{r}
ids.with.QD <- unique(pns.quit.dates$id)
ids.raw <- unique(df.raw$Part_ID)
ids.analysis <- unique(df.post.quit.random$id)

n.with.QD <- length(ids.with.QD)
n.raw <- length(ids.raw)
n.analysis <- length(ids.analysis)
```

Study staff recorded quit dates for `r n.with.QD` participants. However, only data from `r n.raw` participants have been recorded in post-quit random raw data.

```{r}
ids.diff <- setdiff(ids.with.QD, ids.raw)
```

None of the participant IDs recorded in `ids.diff` have any record in the post-quit random raw data:

```{r}
ids.diff %in% n.raw
```

Finally, let's check whether the participant IDs that have a record with the post-quit random raw data are the same participant IDs that have a record in the analytic dataset.
```{r}
setequal(ids.raw, ids.analysis)
```

# Plots of the data

```{r, fig.height=8, fig.width=8}
library(ggplot2)
df.plot <- df.post.quit.random %>%
  mutate(t = time.unixts.scaled/(60*60*24) + 4/24) %>%  # t is 12AM on Quit Day
  mutate(engaged.yes = as.factor(engaged.yes))
gg.all <- ggplot(df.plot)

all.inc <- seq(1,21,1)
for(i in 1:length(all.inc)){
  inc <- all.inc[i]
  gg.all <- gg.all + annotate("rect", xmin= -2/24 + inc, xmax=8/24 + inc, ymin=3000, ymax=Inf, alpha=0.2, fill="black") 
}

gg.all <- gg.all + geom_point(aes(t, id, color=engaged.yes), alpha=0.5)
gg.all <- gg.all + labs(x = "No. of Days since 12AM on Quit Day")
gg.all <- gg.all + labs(y="Each row is one participant's data")
gg.all <- gg.all + labs(title = "Time of EMA delivery \nAll Random EMAs within 21-Day Post Quit Period")
gg.all <- gg.all + labs(subtitle = "Shaded area denotes time between 10PM - 8AM \nEach point denotes one random EMA")
gg.all <- gg.all + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
gg.all <- gg.all + theme(legend.position = "bottom")

# Zoom to first few days
gg.all + xlim(0,3)

# Plot all days
gg.all
```

```{r}
library(ggplot2)
library(grid)
library(gridExtra)
set.seed(3798)

df.plot <- df.post.quit.random %>%
  mutate(t = time.unixts.scaled/(60*60*24) + 4/24) %>%  # t is 12AM on Quit Day
  mutate(Affect6 = if_else(engaged.yes==0, as.integer(0), Affect6)) %>% # For plotting
  mutate(Affect8 = if_else(engaged.yes==0, as.integer(0), Affect8)) %>%
  mutate(engaged.yes = as.factor(engaged.yes))

cols <- c("0" = "red", "1" = "blue")

ids <- unique(df.plot$id)
ids <- sample(ids, size=32)
```


```{r, fig.height=11, fig.width=8}
collect.plots <- list()
for(i in 1:length(ids)){
  use.this.id <- ids[i]
  df.plot.this.participant <- df.plot %>% filter(id==use.this.id)
  gg.all <- ggplot(df.plot.this.participant)
  
  all.inc <- seq(1,21,1)
  for(i in 1:length(all.inc)){
    inc <- all.inc[i]
    gg.all <- gg.all + annotate("rect", xmin= -2/24 + inc, xmax=8/24 + inc, ymin=0, ymax=5.2, alpha=0.2, fill="black") 
  }
  
  gg.all <- gg.all + geom_point(aes(t, Affect6, color=engaged.yes), alpha=0.5)
  gg.all <- gg.all + scale_colour_manual(values = cols)
  #gg.all <- gg.all + labs(x = "No. of Days since 12AM on Quit Day")
  #gg.all <- gg.all + labs(y="Response to EMA item")
  gg.all <- gg.all + labs(x="", y="")
  gg.all <- gg.all + scale_y_continuous(breaks = c(1,2,3,4,5), labels = c("1","2","3","4","5"))
  gg.all <- gg.all + theme(legend.position = "None")
  
  # Plot all days
  collect.plots <- append(collect.plots, list(gg.all))
}

plot.grid <- marrangeGrob(grobs = collect.plots, ncol=4, nrow = 8,
                          top = textGrob("Time of EMA delivery versus response to Affect6 ('I feel angry.') on a 5-point Likert scale\nfor a sample of individuals from the PNS study\nAll Random EMAs within 21-Day Post Quit Period",
                                         gp=gpar(fontsize=11,font=3)
                                         ),
                          bottom = textGrob("Shaded area denotes time between 10PM - 8AM \nEach point denotes one random EMA (red dots: engaged.yes=0, blue dots: engaged.yes=1)",
                                         gp=gpar(fontsize=11,font=3)
                                         )
                          )

plot.grid
```

```{r, fig.height=11, fig.width=8}
collect.plots <- list()
for(i in 1:length(ids)){
  use.this.id <- ids[i]
  df.plot.this.participant <- df.plot %>% filter(id==use.this.id)
  gg.all <- ggplot(df.plot.this.participant)
  
  all.inc <- seq(1,21,1)
  for(i in 1:length(all.inc)){
    inc <- all.inc[i]
    gg.all <- gg.all + annotate("rect", xmin= -2/24 + inc, xmax=8/24 + inc, ymin=0, ymax=5.2, alpha=0.2, fill="black") 
  }
  
  gg.all <- gg.all + geom_point(aes(t, Affect8, color=engaged.yes), alpha=0.5)
  gg.all <- gg.all + scale_colour_manual(values = cols)
  #gg.all <- gg.all + labs(x = "No. of Days since 12AM on Quit Day")
  #gg.all <- gg.all + labs(y="Response to EMA item")
  gg.all <- gg.all + labs(x="", y="")
  gg.all <- gg.all + scale_y_continuous(breaks = c(1,2,3,4,5), labels = c("1","2","3","4","5"))
  gg.all <- gg.all + theme(legend.position = "None")
  
  # Plot all days
  collect.plots <- append(collect.plots, list(gg.all))
}

plot.grid <- marrangeGrob(grobs = collect.plots, ncol=4, nrow = 8,
                          top = textGrob("Time of EMA delivery versus response to Affect8 ('I feel restless.') on a 5-point Likert scale\nfor a sample of individuals from the PNS study\nAll Random EMAs within 21-Day Post Quit Period",
                                         gp=gpar(fontsize=11,font=3)
                                         ),
                          bottom = textGrob("Shaded area denotes time between 10PM - 8AM \nEach point denotes one random EMA (red dots: engaged.yes=0, blue dots: engaged.yes=1)",
                                         gp=gpar(fontsize=11,font=3)
                                         )
                          )

plot.grid
```


